#+TITLE: My Emacs Configuration
#+AUTHOR: Per Salomonsen (belegaps)

* About This Config

This is my personal Emacs configuration.  I'm beginning to discover
Emacs from scratch, so I'm expecting this configuration to evolve over
the coming months and years.

I was suggested installing the Doom Emacs distribution and did so at
first, but reverted to a scratch install in order to be more in line
with the basic tutorials (and because I'm the prototypical
yak-shaver), but at some point I might go back to a distribution.  Who
knows?

I picked up the idea of using a ~.org~ file for the main Emacs
configuration from Derek Taylor ([[https://www.youtube.com/c/DistroTube][DistroTube on YouTube]]), which seems
like a good idea.  I was already curious about the concept of literal
programming from Haskell, so this fit like a glove.

* Enabling This Configuration File

The only thing needed in ~init.el~ is the following statement to
extract the source code snippets from this file and execute them:

#+begin_example
(org-babel-load-file
 (expand-file-name
  "config.org"
  user-emacs-directory))
#+end_example

Beware, though, that initialization will fail if /this/ file doesn't
contain at least one ~#+begin_src~ section.  This is because the
~org-babel-tangle~ function won't generate an ~.el~ file if there are
no source code sections in this file and, subsequent, the ~load-file~
function will fail because it cannot find the file.

* Configure Package Repositories

The Emacs package system needs at least one repository from which to
install packages.  The following code adds both ~melpa~ and
~melpa-stable~ to the list and initialize the package system.

#+begin_src emacs-lisp -n
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages") t)
  (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (package-initialize)
#+end_src

* ~use-package~

~use-package~ seems to be the thing to use.

#+begin_src emacs-lisp
  ;; Enable use-package when loading
  (eval-when-compile
    (require 'use-package))
#+end_src

* MacOS Danish Keyboard Bindings

Emacs performs low-level keyboard interaction, which is good (who
needs to enter '∂', '∆', or '¬' characters anyway), but there are a
collection of keyboard combinations that I'm used to and cannot do
without.

The following snippet sets the mappings that I absolutely needs, when
doing programming:

#+begin_src emacs-lisp +n 1
  (global-set-key (kbd "M-(") "{")
  (global-set-key (kbd "M-)") "}")
  (global-set-key (kbd "M-8") "[")
  (global-set-key (kbd "M-9") "]")
  (global-set-key (kbd "M-'") "@")
  (global-set-key (kbd "M-i") "|")
  (global-set-key (kbd "M-/") "\\")
#+end_src

* User Interface

A couple of things different from the stock configuration.  First,
remove the toolbar and scroll bar.  Maybe I'm just too used to the
ViM experience.  Anyway, it takes away window real estate.

#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

Next, set the default frame size, when starting up.  This is just
based on my default terminal window size and should probably change in
the future, as I always resize the frame anyway--and position it
somewhere specifically.

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(height . 43))
  (add-to-list 'default-frame-alist '(width . 132))
#+end_src

# $EDITOR

I have configured Emacs as my default editor for command line tools,
like ~git~, using the ~$EDITOR~ environment variable, in ~.zshrc~:

#+begin_src shell-script
# Preferred editor for local and remote sessions
if [[ -n $SSH_CONNECTION ]]; then
  export EDITOR='vim'
else
  export EDITOR='emacsclient'
fi
#+end_src

When logging into the machine over SSH, it uses ~ViM~, but for local
connections, the ~emacsclient~.

The way that works is that, for instance, ~git~ executes ~emacsclient~
with the name of a file containing the commit message for editing and
once that's done, I have to execute the ~server-edit~ function in
Emacs to notify the client that editing is done.

By default, that function is bound to ~C+x #~, which on a danish
keyboard requires pressing ~C-x S-3~.  /That/ sequence does not
preserve tempo, so the following snippet adds a second sequence for
the function, one that doesn't require changing from Ctrl to Shift:

#+begin_src emacs-lisp
  ;; Alternative to "C-x #" to keep editing tempo
  (global-set-key (kbd "C-x C-3") 'server-edit)
#+end_src

# Client/server Mode

Of course, configuring CLI tools to use ~emacsclient~ requires that
the Emacs application starts a server (creates a server socket).  The
following function call does exactly that:

#+begin_src emacs-lisp
  (server-start)
#+end_src

Along with configuring ~Emacs.app~ to launch at login, this ensures
that the editor is always available.

** TODO Consider adding options (-a, -n) to ~$EDITOR~

Adding the '-a <app>' option to ~$EDITOR~ would tell it to start a
different program if ~Emacs.app~ isn't running.  And, adding '-n'
would cause ~Emacs.app~ to open a new frame for the editor.  (I'm not
entirely sold on that idea though.)

* Projectile

The projectile package adds features for working with "projects", for
instance project management and navigation.

#+begin_src emacs-lisp
  (use-package projectile
    :init
    (setq
     projectile-known-projects-file
     (expand-file-name "transient/projectile-bookmarks.eld" user-emacs-directory))
    :config
    (projectile-mode +1)
    :bind-keymap
    (("s-p" . projectile-command-map)))
#+end_src

The ~:init~ section sets the ~projectile-known-projects-file~ to a
file in the ~.emacs.d/transient~ directory, because that directory
already is listed in ~.gitignore~ and I don't want the known projects
list in version control (it's probably only relevant per computer
anyway).

Next, after loading the plugin, the ~:config~ section enables it
globally and ~:bind-keymap~ adds a custom keyboard prefix, ⌘+p, for
the ~projectile~ key-map.  (I don't expect to be printing directly
from Emacs anyway.  But who knows?)

* Bug References

The ~bug-reference-mode~ generates an overlay in the editor, when the
file contains references to issues.  For now, it is enabled on
~org-mode~ using:

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'bug-reference-mode)
#+end_src

In order to configure it, we need to set the
~bug-reference-bug-regexp~ and ~bug-reference-url-format~ variables.
One is a regular expression to recognise issue tokens, the other is
the format for generating the URL of the link.

But with different trackers used in different projects, I'll configure
those variables as per-directory local variables.  Since we're using
JIRA at work, I'll put a ~.dir-locals.el~ file at the base of the
directory used for work and configure the variables in there:

#+begin_example
  ((org-mode . (
     (bug-reference-bug-regexp . "\\b\\(\\([A-Za-z][A-Za-z0-9]\\{1,10\\}-[0-9]+\\)\\)")
     (bug-reference-url-format . "https://<jira-server>/browse/%s"))))
#+end_example
